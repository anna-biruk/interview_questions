### Explain event delegation (Делегирование событий)

**Делегирование событий** - это метод, включающий добавление слушателей событий к родительскому элементу вместо добавления их к дочерним элементам. Слушатель будет срабатывать всякий раз, когда событие запускается для дочерних элементов из-за всплытия события в DOM. Преимущества этой техники:

- Объем памяти уменьшается, потому что для родительского элемента требуется только один единственный обработчик, вместо того, чтобы присоединять обработчики событий к каждому потомку.

- Нет необходимости отвязать обработчик от удаленных элементов и привязать событие для новых элементов.

### Explain how `this` works in JavaScript

Нет простого объяснения `this`; Это одна из самых запутанных концепций в JavaScript. Простое объяснение состоит в том, что значение `this` зависит от того, как вызывается функция. Я прочитал много объяснений по этому поводу в Интернете и нашел объяснение Арнава Аггравала наиболее ясным. Применяются следующие правила:

1. Если при вызове функции используется ключевое слово `new`, то внутри функции `this` совершенно новый объект.
2. Если для вызова / создания функции используются `apply`, `call` или `bind`, внутри функции находится `this`, который передается в качестве аргумента.
3. Если функция вызывается как метод, например `obj.method ()` - `this`, свойством которого является функция.
4. Если функция вызывается как вызов свободной функции, то есть она была вызвана без каких-либо условий, представленных выше, это глобальный объект. В браузере это объект `window`. Если в строгом режиме ('use strict'), это будет `undefined` вместо глобального объекта.
5. Если применяется несколько из вышеперечисленных правил, побеждает правило, которое выше, и устанавливает значение `this`.
6. Если функция является стрелочной функцией ES2015, она игнорирует все вышеперечисленные правила и получает значение `this` из окружающей ее области во время создания.

Можете ли вы привести пример того, как работа с этим изменилась в ES6? #
ES6 позволяет использовать стрелочные функции, которые используют охватывающую лексическую область видимости. Обычно это удобно, но не позволяет вызывающей стороне управлять контекстом через `.call` или `.apply` - в результате библиотека, такая как `jQuery`, не будет должным образом связывать это в ваших функциях обработчика событий. Таким образом, важно помнить об этом при рефакторинге больших устаревших приложений.
