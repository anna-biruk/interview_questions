### Explain event delegation (Делегирование событий)

**Делегирование событий** - это метод, включающий добавление слушателей событий к родительскому элементу вместо добавления их к дочерним элементам. Слушатель будет срабатывать всякий раз, когда событие запускается для дочерних элементов из-за всплытия события в DOM. Преимущества этой техники:

- Объем памяти уменьшается, потому что для родительского элемента требуется только один единственный обработчик, вместо того, чтобы присоединять обработчики событий к каждому потомку.

- Нет необходимости отвязать обработчик от удаленных элементов и привязать событие для новых элементов.

### Explain how `this` works in JavaScript

Нет простого объяснения `this`; Это одна из самых запутанных концепций в JavaScript. Простое объяснение состоит в том, что значение `this` зависит от того, как вызывается функция. Я прочитал много объяснений по этому поводу в Интернете и нашел объяснение Арнава Аггравала наиболее ясным. Применяются следующие правила:

1. Если при вызове функции используется ключевое слово `new`, то внутри функции `this` совершенно новый объект.
2. Если для вызова / создания функции используются `apply`, `call` или `bind`, внутри функции находится `this`, который передается в качестве аргумента.
3. Если функция вызывается как метод, например `obj.method ()` - `this`, свойством которого является функция.
4. Если функция вызывается как вызов свободной функции, то есть она была вызвана без каких-либо условий, представленных выше, это глобальный объект. В браузере это объект `window`. Если в строгом режиме ('use strict'), это будет `undefined` вместо глобального объекта.
5. Если применяется несколько из вышеперечисленных правил, побеждает правило, которое выше, и устанавливает значение `this`.
6. Если функция является стрелочной функцией ES2015, она игнорирует все вышеперечисленные правила и получает значение `this` из окружающей ее области во время создания.

Можете ли вы привести пример того, как работа с этим изменилась в ES6? #
ES6 позволяет использовать стрелочные функции, которые используют охватывающую лексическую область видимости. Обычно это удобно, но не позволяет вызывающей стороне управлять контекстом через `.call` или `.apply` - в результате библиотека, такая как `jQuery`, не будет должным образом связывать это в ваших функциях обработчика событий. Таким образом, важно помнить об этом при рефакторинге больших устаревших приложений.

### Расскажите, как работает прототипное наследование.

Это чрезвычайно распространенный вопрос на собеседовании по JavaScript. Все объекты JavaScript имеют свойство `__proto__`, за исключением объектов, созданных с помощью `__Object.create (null) __`, то есть ссылки на другой объект, который называется «прототипом» объекта. При доступе к свойству объекта и если свойство не найдено в этом объекте, движок JavaScript просматривает `__proto__` объекта, `__proto__` и так далее, пока не найдет свойство, определенное в одном из `__proto__`s, или пока оно не будет найдено. Достигает конца цепочки прототипов. Это поведение имитирует классическое наследование, но на самом деле это больше делегирование, чем наследование.

```javascript
function Parent() {
  this.name = "Parent";
}

Parent.prototype.greet = function () {
  console.log("Hello from " + this.name);
};

const child = Object.create(Parent.prototype);

child.cry = function () {
  console.log("waaaaaahhhh!");
};

child.cry();
// waaaaaahhhh!

child.greet();
// hello from Parent

child.constructor;
// ƒ Parent() {
//   this.name = 'Parent';
// }

child.constructor.name;
// 'Parent'
```

На заметку:

- `.greet` не определен для дочернего элемента, поэтому движок идет вверх по цепочке прототипов и находит `.greet` в наследуемом от `Parent`.
- Нам нужно вызвать `Object.create` одним из следующих способов для наследования методов прототипа:
  - `Object.create (Parent.prototype)`;
  - Object.create (new Parent(null));
  - Object.create (objLiteral);
  - В настоящее время `child.constructor` указывает на Parent:

Если мы хотим исправить это, можно сделать следующее:

```javascript
function Parent() {
  this.name = "Parent";
}

Parent.prototype.greet = function () {
  console.log("Hello from " + this.name);
};

function Child() {
  Parent.call(this);
  this.name = "Child";
}

Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;

const child = new Child();

child.greet();
// hello from Child

child.constructor.name;
// 'Child'
```
