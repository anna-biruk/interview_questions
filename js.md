### Explain event delegation (Делегирование событий)

**Делегирование событий** - это метод, включающий добавление слушателей событий к родительскому элементу вместо добавления их к дочерним элементам. Слушатель будет срабатывать всякий раз, когда событие запускается для дочерних элементов из-за всплытия события в DOM. Преимущества этой техники:

- Объем памяти уменьшается, потому что для родительского элемента требуется только один единственный обработчик, вместо того, чтобы присоединять обработчики событий к каждому потомку.

- Нет необходимости отвязать обработчик от удаленных элементов и привязать событие для новых элементов.

### Explain how `this` works in JavaScript

Нет простого объяснения `this`; Это одна из самых запутанных концепций в JavaScript. Простое объяснение состоит в том, что значение `this` зависит от того, как вызывается функция. Я прочитал много объяснений по этому поводу в Интернете и нашел объяснение Арнава Аггравала наиболее ясным. Применяются следующие правила:

1. Если при вызове функции используется ключевое слово `new`, то внутри функции `this` совершенно новый объект.
2. Если для вызова / создания функции используются `apply`, `call` или `bind`, внутри функции находится `this`, который передается в качестве аргумента.
3. Если функция вызывается как метод, например `obj.method ()` - `this`, свойством которого является функция.
4. Если функция вызывается как вызов свободной функции, то есть она была вызвана без каких-либо условий, представленных выше, это глобальный объект. В браузере это объект `window`. Если в строгом режиме ('use strict'), это будет `undefined` вместо глобального объекта.
5. Если применяется несколько из вышеперечисленных правил, побеждает правило, которое выше, и устанавливает значение `this`.
6. Если функция является стрелочной функцией ES2015, она игнорирует все вышеперечисленные правила и получает значение `this` из окружающей ее области во время создания.

Можете ли вы привести пример того, как работа с этим изменилась в ES6? #
ES6 позволяет использовать стрелочные функции, которые используют охватывающую лексическую область видимости. Обычно это удобно, но не позволяет вызывающей стороне управлять контекстом через `.call` или `.apply` - в результате библиотека, такая как `jQuery`, не будет должным образом связывать это в ваших функциях обработчика событий. Таким образом, важно помнить об этом при рефакторинге больших устаревших приложений.

### Расскажите, как работает прототипное наследование.

Это чрезвычайно распространенный вопрос на собеседовании по JavaScript. Все объекты JavaScript имеют свойство `__proto__`, за исключением объектов, созданных с помощью `__Object.create (null) __`, то есть ссылки на другой объект, который называется «прототипом» объекта. При доступе к свойству объекта и если свойство не найдено в этом объекте, движок JavaScript просматривает `__proto__` объекта, `__proto__` и так далее, пока не найдет свойство, определенное в одном из `__proto__`s, или пока оно не будет найдено. Достигает конца цепочки прототипов. Это поведение имитирует классическое наследование, но на самом деле это больше делегирование, чем наследование.

```javascript
function Parent() {
  this.name = "Parent";
}

Parent.prototype.greet = function () {
  console.log("Hello from " + this.name);
};

const child = Object.create(Parent.prototype);

child.cry = function () {
  console.log("waaaaaahhhh!");
};

child.cry();
// waaaaaahhhh!

child.greet();
// hello from Parent

child.constructor;
// ƒ Parent() {
//   this.name = 'Parent';
// }

child.constructor.name;
// 'Parent'
```

На заметку:

- `.greet` не определен для дочернего элемента, поэтому движок идет вверх по цепочке прототипов и находит `.greet` в наследуемом от `Parent`.
- Нам нужно вызвать `Object.create` одним из следующих способов для наследования методов прототипа:
  - `Object.create (Parent.prototype)`;
  - Object.create (new Parent(null));
  - Object.create (objLiteral);
  - В настоящее время `child.constructor` указывает на Parent:

Если мы хотим исправить это, можно сделать следующее:

```javascript
function Parent() {
  this.name = "Parent";
}

Parent.prototype.greet = function () {
  console.log("Hello from " + this.name);
};

function Child() {
  Parent.call(this);
  this.name = "Child";
}

Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;

const child = new Child();

child.greet();
// hello from Child

child.constructor.name;
// 'Child'
```

### Что вы думаете о AMD против CommonJS?

Оба являются способами реализации системы модулей, которая изначально не присутствовала в JavaScript до появления ES2015. CommonJS является синхронным, в то время как AMD (Asynchronous Module Definition, асинхронное определение модуля) - соответственно, асинхронным. CommonJS разработан с учетом разработки на стороне сервера, в то время как AMD с поддержкой асинхронной загрузки модулей больше предназначена для браузеров.

Я считаю синтаксис AMD довольно многословным, а CommonJS ближе к стилю, который используется в выражениях импорта в других языках. В большинстве случаев я считаю AMD ненужным, потому что если вы разместите весь свой код в одном объединенном файле, то вы не сможете воспользоваться свойствами асинхронной загрузки. Кроме того, синтаксис CommonJS ближе к стилю написания модулей Node, и поэтому происходит меньше путаницы при переключении между клиентской и серверной разработкой на JavaScript.

Я рад, что с появлением модулей ES2015, которые поддерживают как синхронную, так и асинхронную загрузку, мы, наконец, можем придерживаться одного подхода. Несмотря на то, что они не полностью поддерживаются во всех браузерах и Node, мы можем использовать транспайлеры для преобразования нашего кода.

### В чем различие между переменными, значение которых: `null`, `undefined` и `не объявлено`? Как бы вы проверили их на каждое из этих значений?​

**Необъявленные** переменные создаются, когда вы присваиваете значение идентификатору, который не был ранее создан при помощи `var`,`let` или `const`. Необъявленные переменные будут определены глобально, вне текущей области видимости. В строгом режиме, будет ошибка `ReferenceError`, когда вы попытаетесь назначить значение необъявленной переменной. Необъявленные переменные плохи так же, как и глобальные переменные. Избегайте их любой ценой! Чтобы проверить на их наличие, оберните код в блок `try/catch`.

```javascript
function foo() {
  x = 1; // ReferenceError в строгом режиме
}

foo();
console.log(x); // 1
```

**Переменная undefined** - это переменная, которая была объявлена, но ей не было присвоено значение. Ее тип `undefined`. Если переменной присвоить функцию, которая не возвращает никакого значения, то переменная также будет иметь значение `undefined`. Чтобы проверить это, сравните, используя оператор строгого равенства (===) или `typeof`, который вернет строку 'undefined'. Обратите внимание, что вам не следует использовать оператор абстрактного сравнения для проверки, так как он также вернет `true`, если значение равно `null`.

```javascript
var foo;
console.log(foo); // undefined
console.log(foo === undefined); // true
console.log(typeof foo === "undefined"); // true

console.log(foo == null); // true.
//Неправильно, не используйте это для проверки!

function bar() {}
var baz = bar();
console.log(baz); // undefined
```

Переменной со значением `null` было явно присвоено значение `null`. Она отличается от `undefined` тем, что она была назначена явно. Чтобы проверить на `null`, просто сравните, используя оператор строгого равенства. Обратите внимание, что, как и выше, вы не должны использовать оператор абстрактного равенства (==) для проверки, так как он также вернет true, если значение равно undefined.

```javascript
var foo = null;
console.log(foo === null); // true
console.log(typeof foo === "object"); // true

console.log(foo == undefined); // true.
// Неправильно, не используйте это для проверки!
```

### Что такое замыкание и как/для чего его используют?​

**Замыкание** - это комбинация функции и лексического окружения, в которой эта функция была объявлена. Слово "лексический" относится к тому факту, что лексическая область видимости использует место, где переменная объявлена в исходном коде, чтобы определить, где эта переменная доступна.
Замыкания - это функции, которые имеют доступ к переменным внешней (замыкающей) функции - цепочке областей видимости даже после того, как внешняя функция вернулась.

Для чего его используют?

- Конфиденциальность данных / эмуляция скрытых методов при помощи замыканий. Обычно используется в модульном паттерне.
- Частичное применение функций или каррирование.

### Можете ли вы описать основное различие между циклом `.forEach` и циклом `.map()`? И в каких случаях каждый из них используется?

Чтобы понять разницу между ними, давайте посмотрим, что делает каждая функция.

`forEach`

- Перебирает элементы в массиве.
- Вызывает callback-функцию для каждого элемента.
- Не возвращает значение.

```javascript
const a = [1, 2, 3];
const doubled = a.forEach((num, index) => {
  // Делаем что-либо с num и/или index.
});

// doubled = undefined
```

`map`

- Перебирает элементы в массиве.
- "Сопоставляет" каждый элемент с новым элементом, вызывая функцию для каждого элемента, создавая в результате новый массив.

```javascript
const a = [1, 2, 3];
const doubled = a.map((num) => {
  return num * 2;
});

// doubled = [2, 4, 6]
```

Основное различие между `.forEach` и `.map()` состоит в том, что `.map()` возвращает новый массив. Если вам нужен результат, но вы не хотите изменять исходный массив, `.map()` - очевидный выбор. Если вам просто нужно перебрать массив, то стоит воспользоваться `forEach`.

### В каких случаях обычно используются анонимные функции?

Они могут использоваться в IIFE для инкапсуляции кода в локальную область видимости, чтобы объявленные в ней переменные не попадали в глобальную область видимости.

```javascript
(function () {
  // Здесь код функции.
})();
```

Как callback-функция, которая используется один раз и не должна использоваться где-либо еще. Код будет казаться более автономным и читаемым, когда обработчики будут определены прямо внутри вызывающего их кода, а не искать в другом месте, чтобы найти тело функции.

```javascript
setTimeout(function () {
  console.log("Hello world!");
}, 1000);
```

Аргументы в конструкциях функционального программирования или Lodash (аналогично callback-функциям).

```javascript
const arr = [1, 2, 3];
const double = arr.map(function (el) {
  return el * 2;
});
console.log(double); // [2, 4, 6]
```

### В чем разница между host-объектами и нативными объектами?

**Нативные объекты** - это объекты, которые являются частью языка JavaScript, определенного в спецификации ECMAScript, такие как `String`,`Math`, `RegExp`,`Object`, `Function` и т.д.

**Хост-объекты** предоставляются средой выполнения (браузером или Node), такие как `Window`, `XMLHTTPRequest` и т.д.

### В чем разница между: `function Person(){}`, `var person = Person()`, и `var person = new Person()`?

Этот вопрос не совсем понятен. Я полагаю, что суть вопроса о конструкторах в JavaScript. Строго говоря, `function Person(){}` - это обычное объявление функции. Принято называть с заглавной буквы функции, которые предназначены для использования в качестве конструкторов.

`var person = Person()` вызывает Person как функцию, а не как конструктор. Вызов как таковой является распространенной ошибкой, если функция предназначена для использования в качестве конструктора. Как правило, конструктор ничего не возвращает, поэтому при вызове конструктора как обычной функции возвращается `undefined`, и это присваивается переменной, предназначенной в качестве экземпляра.

`var person = new Person()` создает экземпляр объекта `Person` с помощью оператора `new`, который наследуется от `Person.prototype`. Альтернативой может быть использование `Object.create`, например:`Object.create(Person.prototype)`.

```javascript
function Person(name) {
  this.name = name;
}

var person = Person("John");
console.log(person); // undefined
console.log(person.name); // Uncaught TypeError: Cannot read property 'name' of undefined

var person = new Person("John");
console.log(person); // Person { name: "John" }
console.log(person.name); // "john"
```

### В чем разница между `.call` и `.apply`?

Сходство заключается в том, что и `.call`, и `.apply` используются для вызова функций, а также первый параметр будет использоваться как значение `this` внутри функции. А разница в том, что `.call` в качестве следующих аргументов принимает аргументы, разделенные запятыми, в то время как `.apply` в качестве следующих аргументов принимает массив аргументов.

```javascript
function add(a, b) {
  return a + b;
}

console.log(add.call(null, 1, 2)); // 3
console.log(add.apply(null, [1, 2])); // 3
```

### Что делает и для чего нужна функция `Function.prototype.bind`?

Метод `bind()` создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения `this` предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.

```javascript
function f() {
  console.log(this.x);
}
var bound = f.bind({ x: 3 });
// bound - новая функция - "обертка", у которой this ссылается на объект {x:3}
bound(); // Выведет 3
```

Для упрощения рассмотрим сразу пример использования bind для частичного применения функций

```javascript
function f(x, y, z) {
  console.log(x + y + z);
}
var bound = f.bind(null, 3, 5); // напомню что первый параметр - это контекст для функции, поскольку мы не используем this в функции f, то контекст не имеет значения - поэтому в данном случае передан null
bound(7); // распечатает 15 (3 + 5 + 7)
bound(17); // распечатает 25 (3 + 5 + 17)
```

По моему опыту, это наиболее полезно для привязки значения `this` в методах классов, которые вы хотите передать в другие функции. Это часто делается в компонентах React.

### В каких случаях используется `document.write()`?​

`document.write()` записывает строку текста в поток документа, открытого при помощи `document.open()`. Когда `document.write()` выполняется после загрузки страницы, он вызывает `document.open`, который очищает весь документ (<head>и<body> будут удалены!) и заменяет содержимое на заданное значение параметра. Подобный подход считается опасным и не рекомендуется его использовать.

В Интернете есть несколько ответов, которые объясняют, что `document.write()` используется в коде отслеживания или когда вы хотите добавить стили, которые должны работать только при включенном JavaScript. Он даже используется в шаблоне HTML5 для параллельной загрузки скриптов и сохранения порядка выполнения! Тем не менее, я подозреваю, что эти причины могут быть устаревшими, и в наши дни они могут быть достигнуты без использования `document.write()`.

### Расскажите, что такое поднятие (hoisting)​

Поднятие (hoisting) - это термин, используемый для объяснения поведения объявлений переменных в вашем коде. Переменные, объявленные или инициализированные при помощи ключевого слова `var`, будут перемещены в верхнюю часть текущей области, что мы называем "поднятием". Однако, "поднимается" только объявление переменной, присвоение значения (если оно имеется) останется на прежнем месте.

Обратите внимание, что объявление фактически не перемещается - движок JavaScript анализирует объявления во время компиляции и узнает о объявлениях и их областях видимости. Просто легче понять подобное поведение, представляя объявления как перемещение наверх своей области видимости. Давайте рассмотрим несколько примеров.

```javascript
// объявления переменных через var поднимаются.
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1

// объявления переменных через let/const НЕ поднимаются.
console.log(bar); // ReferenceError: bar is not defined
let bar = 2;
console.log(bar); // 2
```

При объявлении функции ее тело поднимается наверх, в то время как у функциональных выражений (когда переменной присваивается функция) поднимается только переменная.

```javascript
// Объявление функции
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log("FOOOOO");
}
console.log(foo); // [Function: foo]

// Функциональное выражение
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function () {
  console.log("BARRRR");
};
console.log(bar); // [Function: bar]
```

### Объясните, что такое всплытие событий (event bubbling)

Когда событие срабатывает на элементе DOM, оно попытается обработать событие (если привязан обработчик), затем событие всплывет вверх к своему родителю и это повторится снова. Подобное всплытие проходит по всем предкам элемента вплоть до `document`. Всплытие событий является механизмом, на котором основано делегирование событий.
