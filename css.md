### Что такое специфичность селекторов CSS и как она работает?

**Специфичность селектора** (еще называют весом) это свойство определяющее приоритет стилевого правила, то есть то, какой стиль будет применен к HTML элементу в итоге. Например, используя какую-нибудь UI библиотеку, элементам этой библиотеки будут применены правила заданные авторами по умолчанию. При необходимости можно поменять стили на свои, «перебив» дефолтные более специфичным селектором.

В следующем списке типы селекторов расположены по возрастанию специфичности:

- селекторы типов элементов (например, `h1`) и псевдоэлементов (например, `::before`).
- селекторы классов (например, `.example`), селекторы атрибутов (например, [type="radio"]) и псевдоклассов (например, `:hover`).
- селекторы идентификаторов (например, `#example`).

Универсальный селектор (\*), комбинаторы (`+, >, ~, ' '`) и отрицающий псевдокласс (`:not()`) **не влияют на специфичность**. (Однако селекторы, объявленные внутри `:not()`, влияют)

Стили, объявленные в элементе (например, `style="font-weight:bold"`), всегда переопределяют любые правила из внешних файлов стилей и, таким образом, их специфичность можно считать наивысшей.

Когда при объявлении стиля используется модификатор `!important`, это объявление получает наивысший приоритет среди всех прочих объявлений.

**Несколько практических советов:**

- Всегда пытайтесь использовать специфичность, а `!important`используйте только в крайних случаях
- Используйте `!important` только в страничных стилях, которые переопределяют стили сайта или внешние стили (стили библиотек, таких как Bootstrap или normalize.css)
- Никогда не используйте `!important`, если вы пишете плагин или мэшап.
- Никогда не используйте `!important` в общем CSS сайта.

Вместо !important можно:

Лучше использовать каскадные свойства CSS
Использовать более специфичные правила. Чтобы сделать правило более специфичным и повысить его приоритет, укажите один элемент или несколько перед нужным вам элементом:

```html
<div id="test">
  <span>Text</span>
</div>
```

```html
div#test span { color: green } div span { color: blue } span { color: red }
```

Вне зависимости от порядка следования правил, текст всегда будет зелёным, поскольку у этого правила наибольшая специфичность (при этом, правило для голубого цвета имеет преимущество перед правилом для красного, несмотря на порядок следования).

### Какая разница между сбросом и нормализацией CSS? Что вы выберете и почему ?

**Цель сброса CSS** — сбросить все стили в ноль для того, чтобы можно было начать стилизацию сайта с чистого листа. Недостатком сброса стилей является то, что частично их придется устанавливать заново.
**Цель нормализации** — привести исходные стили к единому состоянию, во всех браузерах. Если рассматривать Normalize.css, то с его помощью не просто устанавливаются определенные значения стилей, но и решаются некоторые проблемы отображения элементов, в особенности в мобильных браузерах. Выбирать между двумя инструментами стоит в зависимости от поставленной задачи.

### За что отвечает свойство float и как оно работает ?

Определяет сторону, по которой будет выровнен элемент. Соседние элементы будут «обтекать» такой элемент по противоположной стороне.

### Что делает свойство z-index и как формируется контекст наложения?

Определяет положение элемента по оси Z. Если элементы перекрываются друг другом (накладываются), это свойство диктует порядок наложения. Работает только для элементов у которых свойство position установлено как `absolute/relative/fixed`.

### Какие существуют методы очистки `floats` и какие из них подходят для какого контекста ?

Свойство `clear`, примененное к нижестоящему (от `float`) элементу со значениями `left, right, both,` а также свойство `overflow` со значением `hidden`. Само по себе свойство `overflow` управляет отображением содержимого блока (добавляет полосы прокрутки, обрезает не поместившийся контент), в добавок, значения `auto`, `scroll` или `hidden` отменяют свойство `float`.

### Каким образом вы боритесь с проблемами стилизации, связанными с кросс-браузерностью?

Есть несколько основных решений проблем стилизации, связанных с кросс-браузерностью. Например, разделение стилей для разных браузеров и устройств, а также добавление вендорных префиксов к стилевым правилам. Метод разделения стилей заключается в идентификации вида браузера пользователя и применении соответствующего стиля совместно с основным, путем добавления условных комментариев (для IE) или CSS-хаков. С помощью правила `@media` можно указать тип устройства, для которого будет применены определенные стили, а добавление вендорных префиксов к стилям расширит список поддерживаемых браузеров.

### Как работать со стилями в старых браузерах с ограниченными возможностями? Какие методы/техники вы используете ?

Подход **progressive enhancement** предполагает поэтапное создание веб-интерфейсов, должны создаваться поэтапно, циклически, от простого к сложному. На каждом из этапов создается законченный веб-интерфейс, как улучшенная версия предыдущего. Всего можно выделить 4 этапа:

- HTML — содержимое страницы размечается с помощью HTML. Важно сделать логически и семантически правильную разметку, тогда документ будет корректно отображен любым браузером. Этот этап является самым важным.
- CSS — документ получает аккуратный вид: появляется сетка страницы, фоновые изображения и т.д.
- CSS3 — добавляются анимационные и декоративные фишки, тени, плашки, уголки и т.д.
- JavaScript — улучшается взаимодействие с интерфейсом: AJAX решения, динамические элементы и т.д.

Такой подход в сочетании с _mobile first_ гарантирует, что страница сайта будет корректно отображаться на любых устройствах. Подход **graceful degradation** имеет обратную философию — функционал сайта деградирует от сложного к более простому в ранних версиях браузеров, где еще не реализованы последние фичи. Для определения наличия нужного функционала браузера используется другой прием — feature detection (правило @supports)

### Какие вы знаете способы для скрытия контента сайта (при этом оставив его доступным для скринридеров)?

Свойство `opacity` со значением 0 скрывает элемент и все его дочерние элементы. Скрытый контент всё ещё присутствует на странице, его место ничем не занято. Техника `.sr-only `позволяет скрыть элемент, но оставить его доступным для скринридеров

```html
.sr-only { border: 0; clip: rect(0 0 0 0); height: 1px; margin: -1px; overflow:
hidden; padding: 0; position: absolute; width: 1px; }
```

### Что вы можете рассказать о медиа-запросах ?

Медиа-запросы позволяют адаптировать страницы для разных типов устройств (принтеров, речевых браузеров и т.д.) или для устройств с определенными характеристиками: ширина (width), высота (height), соотношение ширины к высоте области просмотра (aspect-ratio), ориентация (orientation), разрешение (resolution), количество бит на каждый из цветовых компонентов устройства (color) и другие.

### Приведите какой-либо пример свойства @media отличительного от @media screen ?

**@media all** — значение по умолчанию, для всех типов устройств.
**@media print** — принтеры.
**@media speech** — программы для воспроизведения текста вслух (в том числе речевые браузеры) и речевые синтезаторы.

### Какие моменты по написанию эффективного CSS вы бы выделили?

- Код должен быть валидным (корректно выполняться).
- Комментарии должны быть подробными.
- Код должен быть разбит на логические блоки, каждый блок нужно отделять пустой строкой.
- Использование иерархии облегчает чтение кода.
- Свойства желательно размещать в алфавитном порядке.
- Каскадные таблицы (CSS) нужно размещать в отдельном файле.
- Неиспользуемые селекторы нужно удалять.
- Нужно использовать там, где возможно, универсальные свойства.

### Какие существуют псевдоэлементы и для чего они используются.

**Псевдоэлемент в CSS** — это ключевое слово, которое добавляется к селектору и позволяет стилизовать определенную часть выбранного элемента.
Псевдоэлементы: `:after, :before, :first-letter, :first-line`.
`:after` — применяется для вставки нужного контента после выбранного элемента. Применяется со свойством content, которое определяет содержимое для вставки.
`:before` — применяется для вставки нужного контента до выбранного элемента. Также необходимо задать свойство content с содержимым для вставки.
`:first-letter` — добавляет к первому элементу в тексте и определяет его стиль: можно создавать буквицу (увеличенную первую букву, базовая линия которой ниже на одну или несколько строк базовой линии основного текста) или выступающий инициал (увеличенная прописная буква, линия которой совпадает с линией основного текста).
`:first-line` — используется для изменения первой строки блочного текста.

### Что такое блочная модель, и как, с помощью CSS, менять расположение блоков на странице в браузере?

**Блочная модель** — модель, при которой каждый элемент представляет собой прямоугольный блок и имеет ширину, высоту, поля, границы и отступы. Менять расположение элементов можно с помощью позиционирования (position), отступов (margin) и трансформирования (transform).

### Что делает свойство `*{box-sizing: border-box;}`? Какие его преимущества ?

При использовании `box-sizing: border-box` свойства `width` и `height` включают в себя значения `padding` и `border`, но не отступов (margin). Т.е. объект остается с фиксированными параметрами, но уменьшается место для контента. При использовании `border-box`, не нужно беспокоиться о том, сколько места будет занимать отступ или граница, так как эти значения просто отнимаются от общей ширины, а не добавляются к ней.

### За что отвечает свойство display в CSS? Приведите пару примеров его использования.

Свойство `display` определяет как элемент будет показан в документе.
Если указать свойству `display` значение **none**, то элемент и все его дочерние элементы будет удалены из дерева доступности (объект в котором хранится информация для вспомогательных технологий по обеспечению доступности сайта для людей с повышенными потребностями) и не будут восприниматься технологиями чтения экранов.
Значение свойства `display — contents`, удаляет элемент из дерева доступности, дочерние элементы становятся дочерними элементами следующего уровня в DOM.

### Объясните разницу между значениями inline и inline-block ?

`Inline` и `inline-block` это значения, которые можно назначить свойству `display`.
При использовании `inline` для любого элемента он становится строчным.
`Inline-block` объединяет в себе характеристики как строчных, так и блочных элементов: блочный элемент с поведением, как у строчного.
Содержимое таких элементов будет отображаться, как обычно, но при этом блоки будут вести себя как строчные элементы, выстраиваясь в одной строке друг за другом и переносясь на новую строку лишь при необходимости.

### Объясните разницу между псевдоклассами «nth-of-type()» и «nth-child()» ?

**nth-of-type()** используется для добавления стиля к элементам указанного типа на основе нумерации в дереве элементов.
**nth-child()** это псевдокласс, который используется для выбора дочерних элементов с помощью числового выражения без учета типов элементов.

### Объясните разницу между relative, fixed, absolute и static — видами позиционирования элемента ?

**Relative** — положение элемента задается относительно исходного расположения. Сам элемент становится родительским для всех дочерних, абсолютно позиционировнных элементов.
**Fixed** — положение элемента привязывается к указанной свойствами `left, top, right и bottom `точке на экране и не меняет своего положения при прокрутке страницы.
**Absolute** — положение элемента задается относительно границ родительского элемента (тот у которого `position: relative`), элемент выпадает из изначального контекста.
**Static** — положение элемента остается неизменным. Такой вид позиционирования еще называют нормальным. Элементы отображаются в том же порядке, как они идут в исходном коде.

### Разница adaptive vs responsive design?

Responsive Web Design (RWD) — отзывчивый веб-дизайн, Adaptive Web Design (ADW) — адаптивный веб-дизайн. Каждый из терминов обозначает особый подход к созданию вашего веб-сайта и используется для описания процесса создания веб-сайта, который будет удобно просматривать с различных мобильных устройств.

При создании **Responsive (отзывчивого)** веб-сайта используется гибкая структура страницы — «резиновый макет» (fluid grid), пропорции и размеры элементов которой задаются в процентах. Помимо «резиновой» структуры, используются гибкие изображения (fluid images), «резиновые» текстовые блоки. При уменьшении ширины такой страницы весь контент плавно сожмется, структурные элементы уменьшатся относительно друг друга. Так, например, если ваш веб-сайт имел 3-х колончатую структуру, то на более узком экране он будет иметь две или одну колонку контента.

Для создания **responsive** версии веб-сайта используются медиа запросы (media queries) — блоки кода с указанием параметров устройств вывода. Медиа запросы позволяют применять определенные правила (стили) для вывода различных контентных блоков в различном порядке и пропорциях в зависимости от ширины экрана и возможностей устройства, на котором происходит просмотр веб-сайта.

**Адаптивные веб-сайты (ADV)** внешне могут быть похожи на респонсив, но ключевым различием между ними является то, что может быть незаметно глазу простого пользователя — для адаптивного веб-сайта заранее создается набор различных вариантов шаблонов (разметки) для устройств с разной шириной экранов, а также определяется функционал, которым может обладать определенная версия для определённых типов устройств.

Например, при создании сайта проектируется дизайн страниц нескольких типовых размеров по ширине: 320 px для смартфонов, 760 px, 1024 px для планшетов и 1680 px для десктоп браузеров. Когда пользователь заходит на адаптивный сайт, сервер определяет, при помощи какого устройства осуществляется просмотр, и показывает юзеру нужный контент и шаблон.

Теперь представим, что вам нужно решить, какой подход будет использоваться при создании вашего сайта.

**Респонсив сайты** больше подходят тогда, когда нет разницы между просмотром и использованием веб-сайта на мобильном и десктоп устройстве, а также когда бюджет и срок разработки ограничены.

**Адаптивные сайты** подходят в большинстве случаев, но наиболее востребованы именно тогда, когда важна скорость загрузки страниц и взаимодействие пользователя с мобильной версией сильно отличается от использования браузерной десктоп версии.

### CSS3 новые возможности, псевдоклассы, псевдоэлементы, псевдоклассы привязки

- Одиночное двоеточие `:` используется для псевдоклассов CSS3, а двойное двоеточие `: :` используется для псевдоэлементов CSS3.
- Псевдоклассы CSS: используются для добавления специальных эффектов к определенным селекторам. (`: Hover: active:` посещено)
- Псевдоэлементы CSS: используются для добавления специальных эффектов к определенным селекторам. Псевдоэлемент представляет собой дочерний элемент элемента. Хотя этот дочерний элемент существует логически, на самом деле он не существует в дереве документа. (`::`До после)

### Каков приоритет CSS-селекторов?

! important> Встроенный стиль> Селектор идентификатора> Селектор классов> Тег> Подстановочный знак> Наследование> Свойства браузера по умолчанию.

### В чем особенность селектора CSS и как он работает?

Браузер определяет, какие стили отображать в элементе, в зависимости от специфики правил CSS. Мы предполагаем, что браузер уже определил правила, соответствующие определенному элементу. Среди правил сопоставления специфичность, четыре значения, разделенные запятыми, `a, b, c, d, `рассчитываются для каждого правила на основе следующего:

`a` - используются ли встроенные стили. Если объявление свойства является встроенным стилем элемента, a равно 1, иначе 0.
`b` - количество селекторов ID.
`c` - количество классов, атрибутов и селекторов псевдоклассов.
`d` - количество тегов и селекторов псевдоэлементов.

Результирующая специфичность - это не оценка, а матрица значений, которые можно сравнивать столбец за столбцом. При сравнении селекторов, чтобы определить, какой из них имеет наибольшую специфичность, смотрите слева направо и сравнивайте наибольшее значение в каждом столбце. Таким образом, значение в столбце b переопределит значения в столбцах c и d, какими бы они ни были. Таким образом, специфичность `0,1,0,0` будет больше, чем `0,0,10,10`.

В случаях одинаковой специфичности: последнее правило имеет значение. Если вы записали одно и то же правило в таблицу стилей (независимо от того, является ли он внутренним или внешним) дважды, то нижнее правило в таблице стилей ближе к элементу, который нужно стилизовать, оно считается более конкретным и, следовательно, будет применяться.

Я бы написал правила CSS с низкой специфичностью, чтобы их можно было легко переопределить в случае необходимости. При написании кода библиотеки компонентов пользовательского интерфейса CSS важно, чтобы они имели низкую специфичность, чтобы пользователи библиотеки могли переопределить их, не используя слишком сложные правила CSS, просто ради повышения специфичности или прибегая к
`!Important`.

### В чем разница между «сбросом» и «нормализацией» CSS? Что бы вы выбрали и почему?

- **Resetting** - Сброс предназначен для удаления всех стилей браузера по умолчанию на элементах. Например, `margins, paddings, font-sizes` всех элементов сбрасываются и становятся одинаковыми. Вам придется заново объявить стиль для общих типографских элементов.

- **Normalizing** - сохраняет полезные стили по умолчанию, а не «деформирует» все. Он также исправляет ошибки для общих зависимостей браузера.

Я бы выбрал сброс, если у меня очень индивидуальный или нетрадиционный дизайн сайта, так что мне нужно сделать много собственного стиля и не нужно сохранять стили по умолчанию.

### Describe floats and how they work (Опишите `floats` и как они работают)

Float - это свойство позиционирования CSS. Плавающие элементы остаются частью потока страницы и будут влиять на расположение других элементов (например, текст будет обтекать плавающие элементы), в отличие от `position: absolute` элементы, которые удаляются из потока страницы.

Свойство CSS `clear` можно использовать для размещения под левым / правым / обоими плавающими элементами.

Если родительский элемент не содержит ничего, кроме плавающих элементов, его высота будет уменьшена до нуля. Это можно исправить, очистив поплавок после плавающих элементов в контейнере, но до закрытия контейнера.

Хак `.clearfix` использует умный псевдоселектор CSS (`: after`) для очистки числа с плавающей запятой. Вместо того, чтобы устанавливать переполнение для родительского элемента, вы применяете к нему дополнительный класс `clearfix`. Затем примените этот CSS:

```CSS
.clearfix:after {
  content: ' ';
  visibility: hidden;
  display: block;
  height: 0;
  clear: both;
}
```

В качестве альтернативы, присвойте родительскому элементу свойство `overflow: auto` или `overflow: hidden`, которое установит новый контекст форматирования блока внутри дочерних элементов, и он будет расширяться, чтобы содержать своих дочерних элементов.

### Опишите `z-index` и как формируется контекст стекирования.

Свойство `z-index` в CSS контролирует вертикальный порядок расположения перекрывающихся элементов. `Z-index` влияет только на элементы, значение позиции которых не является статическим.

Без какого-либо значения z-индекса элементы складываются в том порядке, в котором они появляются в DOM (самый нижний на том же уровне иерархии появляется сверху). Элементы с нестатическим позиционированием (и их дочерние элементы) всегда будут отображаться поверх элементов со статическим позиционированием по умолчанию, независимо от иерархии HTML.

Контекст наложения - это элемент, содержащий набор слоев. В локальном контексте стекирования значения `z-index` его дочерних элементов устанавливаются относительно этого элемента, а не корня документа. Слои вне этого контекста - т.е. одноуровневые элементы локального контекста стекирования - не могут находиться между слоями внутри него. Если элемент B находится поверх элемента A, дочерний элемент элемента A, элемент C, никогда не может быть выше элемента B, даже если элемент C имеет более высокий `z-index`, чем элемент B.

Каждый контекст наложения является самодостаточным - после наложения содержимого элемента весь элемент рассматривается в порядке наложения родительского контекста наложения. Несколько свойств CSS запускают новый контекст наложения, например `opasity` меньше 1, `filter`, который не равен `none`, и `transform`, которое не является пустым.

### Опишите Block Formatting Context (контекст форматирования блока) (BFC) и его работу.

Контекст форматирования блока (BFC) - это часть визуального CSS-рендеринга веб-страницы, в которой размещены блоки блоков. Поплавки, элементы с абсолютным позиционированием, `inline-block`s, `table-cell`s, `table-caption`,c `overflow` отличным от `visible` (кроме случаев, когда это значение было передано в область просмотра), устанавливают новые контексты форматирования блоков.

Важно знать, как установить контекст форматирования блока, потому что без этого содержащий блок не будет содержать плавающих дочерних элементов. Это похоже на сворачивание полей, но более коварно, поскольку вы обнаружите, что целые коробки сворачиваются странным образом.

BFC - это блок HTML, который удовлетворяет хотя бы одному из следующих условий:

- Значение `float` не равно `none`.
- Значение `position` не является ни `static`, ни `relative`.
- Значение `display`: `table-cell`, `table-caption`, `inline-block`, `flex` или `inline-flex`, `grid` или `inline-grid`.
- Значение `overflow` не `visible`.

В BFC левый внешний край каждого блока касается левого края содержащего блока (при форматировании справа налево правые края касаются).
