### Что такое специфичность селекторов CSS и как она работает?

**Специфичность селектора** (еще называют весом) это свойство определяющее приоритет стилевого правила, то есть то, какой стиль будет применен к HTML элементу в итоге. Например, используя какую-нибудь UI библиотеку, элементам этой библиотеки будут применены правила заданные авторами по умолчанию. При необходимости можно поменять стили на свои, «перебив» дефолтные более специфичным селектором.

В следующем списке типы селекторов расположены по возрастанию специфичности:

- селекторы типов элементов (например, `h1`) и псевдоэлементов (например, `::before`).
- селекторы классов (например, `.example`), селекторы атрибутов (например, [type="radio"]) и псевдоклассов (например, `:hover`).
- селекторы идентификаторов (например, `#example`).

Универсальный селектор (\*), комбинаторы (`+, >, ~, ' '`) и отрицающий псевдокласс (`:not()`) **не влияют на специфичность**. (Однако селекторы, объявленные внутри `:not()`, влияют)

Стили, объявленные в элементе (например, `style="font-weight:bold"`), всегда переопределяют любые правила из внешних файлов стилей и, таким образом, их специфичность можно считать наивысшей.

Когда при объявлении стиля используется модификатор `!important`, это объявление получает наивысший приоритет среди всех прочих объявлений.

**Несколько практических советов:**

- Всегда пытайтесь использовать специфичность, а `!important`используйте только в крайних случаях
- Используйте `!important` только в страничных стилях, которые переопределяют стили сайта или внешние стили (стили библиотек, таких как Bootstrap или normalize.css)
- Никогда не используйте `!important`, если вы пишете плагин или мэшап.
- Никогда не используйте `!important` в общем CSS сайта.

Вместо !important можно:

Лучше использовать каскадные свойства CSS
Использовать более специфичные правила. Чтобы сделать правило более специфичным и повысить его приоритет, укажите один элемент или несколько перед нужным вам элементом:

```html
<div id="test">
  <span>Text</span>
</div>
```

```html
div#test span { color: green } div span { color: blue } span { color: red }
```

Вне зависимости от порядка следования правил, текст всегда будет зелёным, поскольку у этого правила наибольшая специфичность (при этом, правило для голубого цвета имеет преимущество перед правилом для красного, несмотря на порядок следования).

### Какая разница между сбросом и нормализацией CSS? Что вы выберете и почему ?

**Цель сброса CSS** — сбросить все стили в ноль для того, чтобы можно было начать стилизацию сайта с чистого листа. Недостатком сброса стилей является то, что частично их придется устанавливать заново.
**Цель нормализации** — привести исходные стили к единому состоянию, во всех браузерах. Если рассматривать Normalize.css, то с его помощью не просто устанавливаются определенные значения стилей, но и решаются некоторые проблемы отображения элементов, в особенности в мобильных браузерах. Выбирать между двумя инструментами стоит в зависимости от поставленной задачи.

### За что отвечает свойство float и как оно работает ?

Определяет сторону, по которой будет выровнен элемент. Соседние элементы будут «обтекать» такой элемент по противоположной стороне.

### Что делает свойство z-index и как формируется контекст наложения?

Определяет положение элемента по оси Z. Если элементы перекрываются друг другом (накладываются), это свойство диктует порядок наложения. Работает только для элементов у которых свойство position установлено как `absolute/relative/fixed`.

### Какие существуют методы очистки `floats` и какие из них подходят для какого контекста ?

Свойство `clear`, примененное к нижестоящему (от `float`) элементу со значениями `left, right, both,` а также свойство `overflow` со значением `hidden`. Само по себе свойство `overflow` управляет отображением содержимого блока (добавляет полосы прокрутки, обрезает не поместившийся контент), в добавок, значения `auto`, `scroll` или `hidden` отменяют свойство `float`.

### Каким образом вы боритесь с проблемами стилизации, связанными с кросс-браузерностью?

Есть несколько основных решений проблем стилизации, связанных с кросс-браузерностью. Например, разделение стилей для разных браузеров и устройств, а также добавление вендорных префиксов к стилевым правилам. Метод разделения стилей заключается в идентификации вида браузера пользователя и применении соответствующего стиля совместно с основным, путем добавления условных комментариев (для IE) или CSS-хаков. С помощью правила `@media` можно указать тип устройства, для которого будет применены определенные стили, а добавление вендорных префиксов к стилям расширит список поддерживаемых браузеров.

### Как работать со стилями в старых браузерах с ограниченными возможностями? Какие методы/техники вы используете ?

Подход **progressive enhancement** предполагает поэтапное создание веб-интерфейсов, должны создаваться поэтапно, циклически, от простого к сложному. На каждом из этапов создается законченный веб-интерфейс, как улучшенная версия предыдущего. Всего можно выделить 4 этапа:

- HTML — содержимое страницы размечается с помощью HTML. Важно сделать логически и семантически правильную разметку, тогда документ будет корректно отображен любым браузером. Этот этап является самым важным.
- CSS — документ получает аккуратный вид: появляется сетка страницы, фоновые изображения и т.д.
- CSS3 — добавляются анимационные и декоративные фишки, тени, плашки, уголки и т.д.
- JavaScript — улучшается взаимодействие с интерфейсом: AJAX решения, динамические элементы и т.д.

Такой подход в сочетании с _mobile first_ гарантирует, что страница сайта будет корректно отображаться на любых устройствах. Подход **graceful degradation** имеет обратную философию — функционал сайта деградирует от сложного к более простому в ранних версиях браузеров, где еще не реализованы последние фичи. Для определения наличия нужного функционала браузера используется другой прием — feature detection (правило @supports)

### Какие вы знаете способы для скрытия контента сайта (при этом оставив его доступным для скринридеров)?

Свойство `opacity` со значением 0 скрывает элемент и все его дочерние элементы. Скрытый контент всё ещё присутствует на странице, его место ничем не занято. Техника `.sr-only `позволяет скрыть элемент, но оставить его доступным для скринридеров

```html
.sr-only { border: 0; clip: rect(0 0 0 0); height: 1px; margin: -1px; overflow:
hidden; padding: 0; position: absolute; width: 1px; }
```

### Что вы можете рассказать о медиа-запросах ?

Медиа-запросы позволяют адаптировать страницы для разных типов устройств (принтеров, речевых браузеров и т.д.) или для устройств с определенными характеристиками: ширина (width), высота (height), соотношение ширины к высоте области просмотра (aspect-ratio), ориентация (orientation), разрешение (resolution), количество бит на каждый из цветовых компонентов устройства (color) и другие.

### Приведите какой-либо пример свойства @media отличительного от @media screen ?

**@media all** — значение по умолчанию, для всех типов устройств.
**@media print** — принтеры.
**@media speech** — программы для воспроизведения текста вслух (в том числе речевые браузеры) и речевые синтезаторы.

### Какие моменты по написанию эффективного CSS вы бы выделили?

- Код должен быть валидным (корректно выполняться).
- Комментарии должны быть подробными.
- Код должен быть разбит на логические блоки, каждый блок нужно отделять пустой строкой.
- Использование иерархии облегчает чтение кода.
- Свойства желательно размещать в алфавитном порядке.
- Каскадные таблицы (CSS) нужно размещать в отдельном файле.
- Неиспользуемые селекторы нужно удалять.
- Нужно использовать там, где возможно, универсальные свойства.

### Какие существуют псевдоэлементы и для чего они используются.

**Псевдоэлемент в CSS** — это ключевое слово, которое добавляется к селектору и позволяет стилизовать определенную часть выбранного элемента.
Псевдоэлементы: `:after, :before, :first-letter, :first-line`.
`:after` — применяется для вставки нужного контента после выбранного элемента. Применяется со свойством content, которое определяет содержимое для вставки.
`:before` — применяется для вставки нужного контента до выбранного элемента. Также необходимо задать свойство content с содержимым для вставки.
`:first-letter` — добавляет к первому элементу в тексте и определяет его стиль: можно создавать буквицу (увеличенную первую букву, базовая линия которой ниже на одну или несколько строк базовой линии основного текста) или выступающий инициал (увеличенная прописная буква, линия которой совпадает с линией основного текста).
`:first-line` — используется для изменения первой строки блочного текста.

###  Что такое блочная модель, и как, с помощью CSS, менять расположение блоков на странице в браузере?

**Блочная модель** — модель, при которой каждый элемент представляет собой прямоугольный блок и имеет ширину, высоту, поля, границы и отступы. Менять расположение элементов можно с помощью позиционирования (position), отступов (margin) и трансформирования (transform).


###  Что делает свойство `*{box-sizing: border-box;}`? Какие его преимущества ?

При использовании `box-sizing: border-box` свойства `width` и `height` включают в себя значения `padding` и `border`, но не отступов (margin). Т.е. объект остается с фиксированными параметрами, но уменьшается место для контента. При использовании `border-box`, не нужно беспокоиться о том, сколько места будет занимать отступ или граница, так как эти значения просто отнимаются от общей ширины, а не добавляются к ней.

### За что отвечает свойство display в CSS? Приведите пару примеров его использования.

Свойство `display` определяет как элемент будет показан в документе. 
Если указать свойству `display` значение **none**, то элемент и все его дочерние элементы будет удалены из дерева доступности (объект в котором хранится информация для вспомогательных технологий по обеспечению доступности сайта для людей с повышенными потребностями) и не будут восприниматься технологиями чтения экранов. 
Значение свойства  `display — contents`, удаляет элемент из дерева доступности, дочерние элементы становятся дочерними элементами следующего уровня в DOM.

###  Объясните разницу между значениями inline и inline-block ?

`Inline` и `inline-block` это значения, которые можно назначить свойству `display`. 
При использовании `inline` для любого элемента он становится строчным. 
`Inline-block` объединяет в себе характеристики как строчных, так и блочных элементов: блочный элемент с поведением, как у строчного. 
Содержимое таких элементов будет отображаться, как обычно, но при этом блоки будут вести себя как строчные элементы, выстраиваясь в одной строке друг за другом и переносясь на новую строку лишь при необходимости.

### Объясните разницу между псевдоклассами «nth-of-type()» и «nth-child()» ?

**nth-of-type()** используется для добавления стиля к элементам указанного типа на основе нумерации в дереве элементов.
**nth-child()** это псевдокласс, который используется для выбора дочерних элементов с помощью числового выражения без учета типов элементов.

### Объясните разницу между relative, fixed, absolute и static — видами позиционирования элемента ?

**Relative** — положение элемента задается относительно исходного расположения. Сам элемент становится родительским для всех дочерних, абсолютно позиционировнных элементов.
**Fixed** — положение элемента привязывается к указанной свойствами `left, top, right и bottom `точке на экране и не меняет своего положения при прокрутке страницы.
**Absolute** — положение элемента задается относительно границ родительского элемента (тот у которого `position: relative`), элемент выпадает из изначального контекста.
**Static** — положение элемента остается неизменным. Такой вид позиционирования еще называют нормальным. Элементы отображаются в том же порядке, как они идут в исходном коде.


### Разница adaptive vs responsive design?

Responsive Web Design (RWD) — отзывчивый веб-дизайн, Adaptive Web Design (ADW) — адаптивный веб-дизайн.  Каждый из терминов обозначает особый подход к созданию вашего веб-сайта и используется для описания процесса создания веб-сайта, который будет удобно просматривать с различных мобильных устройств.

При создании **Responsive (отзывчивого)** веб-сайта используется гибкая структура страницы — «резиновый макет» (fluid grid), пропорции и размеры элементов которой задаются в процентах. Помимо «резиновой» структуры, используются гибкие изображения (fluid images), «резиновые» текстовые блоки. При уменьшении ширины такой страницы весь контент плавно сожмется, структурные элементы уменьшатся относительно друг друга. Так, например, если ваш веб-сайт имел 3-х колончатую структуру, то на более узком экране он будет иметь две или одну колонку контента. 

Для создания **responsive** версии веб-сайта используются медиа запросы (media queries) — блоки кода с указанием параметров устройств вывода. Медиа запросы позволяют применять определенные правила (стили) для вывода различных контентных блоков в различном порядке и пропорциях в зависимости от ширины экрана и возможностей устройства, на котором происходит просмотр веб-сайта. 

**Адаптивные веб-сайты (ADV)** внешне могут быть похожи на респонсив, но ключевым различием между ними является то, что может быть незаметно глазу простого пользователя — для адаптивного веб-сайта заранее создается набор различных вариантов шаблонов (разметки) для устройств с разной шириной экранов, а также определяется функционал, которым может обладать определенная версия для определённых типов устройств. 

Например, при создании сайта проектируется дизайн страниц нескольких типовых размеров по ширине: 320 px для смартфонов, 760 px, 1024 px  для  планшетов и 1680 px для десктоп браузеров. Когда пользователь заходит на адаптивный сайт, сервер определяет, при помощи какого устройства осуществляется просмотр, и показывает юзеру нужный контент и шаблон.

Теперь представим, что вам нужно решить, какой подход будет использоваться при создании вашего сайта.

**Респонсив сайты** больше подходят тогда, когда нет разницы между просмотром и использованием веб-сайта на мобильном и десктоп устройстве, а также когда бюджет и срок разработки ограничены.

**Адаптивные сайты** подходят в большинстве случаев, но наиболее востребованы именно тогда, когда важна скорость загрузки страниц и взаимодействие пользователя с мобильной версией сильно отличается от использования браузерной десктоп версии.

