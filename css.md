### Что такое специфичность селекторов CSS и как она работает?

**Специфичность селектора** (еще называют весом) это свойство определяющее приоритет стилевого правила, то есть то, какой стиль будет применен к HTML элементу в итоге. Например, используя какую-нибудь UI библиотеку, элементам этой библиотеки будут применены правила заданные авторами по умолчанию. При необходимости можно поменять стили на свои, «перебив» дефолтные более специфичным селектором.

В следующем списке типы селекторов расположены по возрастанию специфичности:

- селекторы типов элементов (например, `h1`) и псевдоэлементов (например, `::before`).
- селекторы классов (например, `.example`), селекторы атрибутов (например, [type="radio"]) и псевдоклассов (например, `:hover`).
- селекторы идентификаторов (например, `#example`).

Универсальный селектор (\*), комбинаторы (`+, >, ~, ' '`) и отрицающий псевдокласс (`:not()`) **не влияют на специфичность**. (Однако селекторы, объявленные внутри `:not()`, влияют)

Стили, объявленные в элементе (например, `style="font-weight:bold"`), всегда переопределяют любые правила из внешних файлов стилей и, таким образом, их специфичность можно считать наивысшей.

Когда при объявлении стиля используется модификатор `!important`, это объявление получает наивысший приоритет среди всех прочих объявлений.

**Несколько практических советов:**

- Всегда пытайтесь использовать специфичность, а `!important`используйте только в крайних случаях
- Используйте `!important` только в страничных стилях, которые переопределяют стили сайта или внешние стили (стили библиотек, таких как Bootstrap или normalize.css)
- Никогда не используйте `!important`, если вы пишете плагин или мэшап.
- Никогда не используйте `!important` в общем CSS сайта.

Вместо !important можно:

Лучше использовать каскадные свойства CSS
Использовать более специфичные правила. Чтобы сделать правило более специфичным и повысить его приоритет, укажите один элемент или несколько перед нужным вам элементом:

```html
<div id="test">
  <span>Text</span>
</div>
```

```html
div#test span { color: green } div span { color: blue } span { color: red }
```

Вне зависимости от порядка следования правил, текст всегда будет зелёным, поскольку у этого правила наибольшая специфичность (при этом, правило для голубого цвета имеет преимущество перед правилом для красного, несмотря на порядок следования).

### Какая разница между сбросом и нормализацией CSS? Что вы выберете и почему ?

**Цель сброса CSS** — сбросить все стили в ноль для того, чтобы можно было начать стилизацию сайта с чистого листа. Недостатком сброса стилей является то, что частично их придется устанавливать заново.
**Цель нормализации** — привести исходные стили к единому состоянию, во всех браузерах. Если рассматривать Normalize.css, то с его помощью не просто устанавливаются определенные значения стилей, но и решаются некоторые проблемы отображения элементов, в особенности в мобильных браузерах. Выбирать между двумя инструментами стоит в зависимости от поставленной задачи.

### За что отвечает свойство float и как оно работает ?

Определяет сторону, по которой будет выровнен элемент. Соседние элементы будут «обтекать» такой элемент по противоположной стороне.

### Что делает свойство z-index и как формируется контекст наложения?

Определяет положение элемента по оси Z. Если элементы перекрываются друг другом (накладываются), это свойство диктует порядок наложения. Работает только для элементов у которых свойство position установлено как `absolute/relative/fixed`.

### Какие существуют методы очистки `floats` и какие из них подходят для какого контекста ?

Свойство `clear`, примененное к нижестоящему (от `float`) элементу со значениями `left, right, both,` а также свойство `overflow` со значением `hidden`. Само по себе свойство `overflow` управляет отображением содержимого блока (добавляет полосы прокрутки, обрезает не поместившийся контент), в добавок, значения `auto`, `scroll` или `hidden` отменяют свойство `float`.

### Каким образом вы боритесь с проблемами стилизации, связанными с кросс-браузерностью?

Есть несколько основных решений проблем стилизации, связанных с кросс-браузерностью. Например, разделение стилей для разных браузеров и устройств, а также добавление вендорных префиксов к стилевым правилам. Метод разделения стилей заключается в идентификации вида браузера пользователя и применении соответствующего стиля совместно с основным, путем добавления условных комментариев (для IE) или CSS-хаков. С помощью правила `@media` можно указать тип устройства, для которого будет применены определенные стили, а добавление вендорных префиксов к стилям расширит список поддерживаемых браузеров.

### Как работать со стилями в старых браузерах с ограниченными возможностями? Какие методы/техники вы используете ?

Подход **progressive enhancement** предполагает поэтапное создание веб-интерфейсов, должны создаваться поэтапно, циклически, от простого к сложному. На каждом из этапов создается законченный веб-интерфейс, как улучшенная версия предыдущего. Всего можно выделить 4 этапа:

- HTML — содержимое страницы размечается с помощью HTML. Важно сделать логически и семантически правильную разметку, тогда документ будет корректно отображен любым браузером. Этот этап является самым важным.
- CSS — документ получает аккуратный вид: появляется сетка страницы, фоновые изображения и т.д.
- CSS3 — добавляются анимационные и декоративные фишки, тени, плашки, уголки и т.д.
- JavaScript — улучшается взаимодействие с интерфейсом: AJAX решения, динамические элементы и т.д.

Такой подход в сочетании с _mobile first_ гарантирует, что страница сайта будет корректно отображаться на любых устройствах. Подход **graceful degradation** имеет обратную философию — функционал сайта деградирует от сложного к более простому в ранних версиях браузеров, где еще не реализованы последние фичи. Для определения наличия нужного функционала браузера используется другой прием — feature detection (правило @supports)

### Какие вы знаете способы для скрытия контента сайта (при этом оставив его доступным для скринридеров)?

Свойство `opacity` со значением 0 скрывает элемент и все его дочерние элементы. Скрытый контент всё ещё присутствует на странице, его место ничем не занято. Техника `.sr-only `позволяет скрыть элемент, но оставить его доступным для скринридеров

```html
.sr-only { border: 0; clip: rect(0 0 0 0); height: 1px; margin: -1px; overflow:
hidden; padding: 0; position: absolute; width: 1px; }
```

### Что вы можете рассказать о медиа-запросах ?

Медиа-запросы позволяют адаптировать страницы для разных типов устройств (принтеров, речевых браузеров и т.д.) или для устройств с определенными характеристиками: ширина (width), высота (height), соотношение ширины к высоте области просмотра (aspect-ratio), ориентация (orientation), разрешение (resolution), количество бит на каждый из цветовых компонентов устройства (color) и другие.

### Приведите какой-либо пример свойства @media отличительного от @media screen ?

**@media all** — значение по умолчанию, для всех типов устройств.
**@media print** — принтеры.
**@media speech** — программы для воспроизведения текста вслух (в том числе речевые браузеры) и речевые синтезаторы.

### Какие моменты по написанию эффективного CSS вы бы выделили?

- Код должен быть валидным (корректно выполняться).
- Комментарии должны быть подробными.
- Код должен быть разбит на логические блоки, каждый блок нужно отделять пустой строкой.
- Использование иерархии облегчает чтение кода.
- Свойства желательно размещать в алфавитном порядке.
- Каскадные таблицы (CSS) нужно размещать в отдельном файле.
- Неиспользуемые селекторы нужно удалять.
- Нужно использовать там, где возможно, универсальные свойства.

### Какие существуют псевдоэлементы и для чего они используются.

**Псевдоэлемент в CSS** — это ключевое слово, которое добавляется к селектору и позволяет стилизовать определенную часть выбранного элемента.
Псевдоэлементы: `:after, :before, :first-letter, :first-line`.
`:after` — применяется для вставки нужного контента после выбранного элемента. Применяется со свойством content, которое определяет содержимое для вставки.
`:before` — применяется для вставки нужного контента до выбранного элемента. Также необходимо задать свойство content с содержимым для вставки.
`:first-letter` — добавляет к первому элементу в тексте и определяет его стиль: можно создавать буквицу (увеличенную первую букву, базовая линия которой ниже на одну или несколько строк базовой линии основного текста) или выступающий инициал (увеличенная прописная буква, линия которой совпадает с линией основного текста).
`:first-line` — используется для изменения первой строки блочного текста.

###  Что такое блочная модель, и как, с помощью CSS, менять расположение блоков на странице в браузере?

**Блочная модель** — модель, при которой каждый элемент представляет собой прямоугольный блок и имеет ширину, высоту, поля, границы и отступы. Менять расположение элементов можно с помощью позиционирования (position), отступов (margin) и трансформирования (transform).


###  Что делает свойство `*{box-sizing: border-box;}`? Какие его преимущества ?

При использовании `box-sizing: border-box` свойства `width` и `height` включают в себя значения `padding` и `border`, но не отступов (margin). Т.е. объект остается с фиксированными параметрами, но уменьшается место для контента. При использовании `border-box`, не нужно беспокоиться о том, сколько места будет занимать отступ или граница, так как эти значения просто отнимаются от общей ширины, а не добавляются к ней.

### За что отвечает свойство display в CSS? Приведите пару примеров его использования.

Свойство `display` определяет как элемент будет показан в документе. 
Если указать свойству `display` значение **none**, то элемент и все его дочерние элементы будет удалены из дерева доступности (объект в котором хранится информация для вспомогательных технологий по обеспечению доступности сайта для людей с повышенными потребностями) и не будут восприниматься технологиями чтения экранов. 
Значение свойства  `display — contents`, удаляет элемент из дерева доступности, дочерние элементы становятся дочерними элементами следующего уровня в DOM.

###  Объясните разницу между значениями inline и inline-block ?

`Inline` и `inline-block` это значения, которые можно назначить свойству `display`. 
При использовании `inline` для любого элемента он становится строчным. 
`Inline-block` объединяет в себе характеристики как строчных, так и блочных элементов: блочный элемент с поведением, как у строчного. 
Содержимое таких элементов будет отображаться, как обычно, но при этом блоки будут вести себя как строчные элементы, выстраиваясь в одной строке друг за другом и переносясь на новую строку лишь при необходимости.


