### Что такое специфичность селекторов CSS и как она работает?

**Специфичность селектора** (еще называют весом) это свойство определяющее приоритет стилевого правила, то есть то, какой стиль будет применен к HTML элементу в итоге. Например, используя какую-нибудь UI библиотеку, элементам этой библиотеки будут применены правила заданные авторами по умолчанию. При необходимости можно поменять стили на свои, «перебив» дефолтные более специфичным селектором.

В следующем списке типы селекторов расположены по возрастанию специфичности:

- селекторы типов элементов (например, `h1`) и псевдоэлементов (например, `::before`).
- селекторы классов (например, `.example`), селекторы атрибутов (например, [type="radio"]) и псевдоклассов (например, `:hover`).
- селекторы идентификаторов (например, `#example`).

Универсальный селектор (\*), комбинаторы (`+, >, ~, ' '`) и отрицающий псевдокласс (`:not()`) **не влияют на специфичность**. (Однако селекторы, объявленные внутри `:not()`, влияют)

Стили, объявленные в элементе (например, `style="font-weight:bold"`), всегда переопределяют любые правила из внешних файлов стилей и, таким образом, их специфичность можно считать наивысшей.

Когда при объявлении стиля используется модификатор `!important`, это объявление получает наивысший приоритет среди всех прочих объявлений.

**Несколько практических советов:**

- Всегда пытайтесь использовать специфичность, а `!important`используйте только в крайних случаях
- Используйте `!important` только в страничных стилях, которые переопределяют стили сайта или внешние стили (стили библиотек, таких как Bootstrap или normalize.css)
- Никогда не используйте `!important`, если вы пишете плагин или мэшап.
- Никогда не используйте `!important` в общем CSS сайта.

Вместо !important можно:

Лучше использовать каскадные свойства CSS
Использовать более специфичные правила. Чтобы сделать правило более специфичным и повысить его приоритет, укажите один элемент или несколько перед нужным вам элементом:

```html
<div id="test">
  <span>Text</span>
</div>
```

```html
div#test span { color: green } div span { color: blue } span { color: red }
```

Вне зависимости от порядка следования правил, текст всегда будет зелёным, поскольку у этого правила наибольшая специфичность (при этом, правило для голубого цвета имеет преимущество перед правилом для красного, несмотря на порядок следования).

### Какая разница между сбросом и нормализацией CSS? Что вы выберете и почему ?

**Цель сброса CSS** — сбросить все стили в ноль для того, чтобы можно было начать стилизацию сайта с чистого листа. Недостатком сброса стилей является то, что частично их придется устанавливать заново.
**Цель нормализации** — привести исходные стили к единому состоянию, во всех браузерах. Если рассматривать Normalize.css, то с его помощью не просто устанавливаются определенные значения стилей, но и решаются некоторые проблемы отображения элементов, в особенности в мобильных браузерах. Выбирать между двумя инструментами стоит в зависимости от поставленной задачи.

### За что отвечает свойство float и как оно работает ?

Определяет сторону, по которой будет выровнен элемент. Соседние элементы будут «обтекать» такой элемент по противоположной стороне.

### Что делает свойство z-index и как формируется контекст наложения?

Определяет положение элемента по оси Z. Если элементы перекрываются друг другом (накладываются), это свойство диктует порядок наложения. Работает только для элементов у которых свойство position установлено как `absolute/relative/fixed`.

### Какие существуют методы очистки `floats` и какие из них подходят для какого контекста ?

Свойство `clear`, примененное к нижестоящему (от `float`) элементу со значениями `left, right, both,` а также свойство `overflow` со значением `hidden`. Само по себе свойство `overflow` управляет отображением содержимого блока (добавляет полосы прокрутки, обрезает не поместившийся контент), в добавок, значения `auto`, `scroll` или `hidden` отменяют свойство `float`.

### Каким образом вы боритесь с проблемами стилизации, связанными с кросс-браузерностью?

Есть несколько основных решений проблем стилизации, связанных с кросс-браузерностью. Например, разделение стилей для разных браузеров и устройств, а также добавление вендорных префиксов к стилевым правилам. Метод разделения стилей заключается в идентификации вида браузера пользователя и применении соответствующего стиля совместно с основным, путем добавления условных комментариев (для IE) или CSS-хаков. С помощью правила `@media` можно указать тип устройства, для которого будет применены определенные стили, а добавление вендорных префиксов к стилям расширит список поддерживаемых браузеров.

### Как работать со стилями в старых браузерах с ограниченными возможностями? Какие методы/техники вы используете ?

Подход **progressive enhancement** предполагает поэтапное создание веб-интерфейсов, должны создаваться поэтапно, циклически, от простого к сложному. На каждом из этапов создается законченный веб-интерфейс, как улучшенная версия предыдущего. Всего можно выделить 4 этапа:

- HTML — содержимое страницы размечается с помощью HTML. Важно сделать логически и семантически правильную разметку, тогда документ будет корректно отображен любым браузером. Этот этап является самым важным.
- CSS — документ получает аккуратный вид: появляется сетка страницы, фоновые изображения и т.д.
- CSS3 — добавляются анимационные и декоративные фишки, тени, плашки, уголки и т.д.
- JavaScript — улучшается взаимодействие с интерфейсом: AJAX решения, динамические элементы и т.д.

Такой подход в сочетании с _mobile first_ гарантирует, что страница сайта будет корректно отображаться на любых устройствах. Подход **graceful degradation** имеет обратную философию — функционал сайта деградирует от сложного к более простому в ранних версиях браузеров, где еще не реализованы последние фичи. Для определения наличия нужного функционала браузера используется другой прием — feature detection (правило @supports)

### Какие вы знаете способы для скрытия контента сайта (при этом оставив его доступным для скринридеров)?

Свойство `opacity` со значением 0 скрывает элемент и все его дочерние элементы. Скрытый контент всё ещё присутствует на странице, его место ничем не занято. Техника `.sr-only `позволяет скрыть элемент, но оставить его доступным для скринридеров

```html
.sr-only { 
    border: 0; 
    clip: rect(0 0 0 0); 
    height: 1px; 
    margin: -1px; 
    overflow: hidden; 
    padding: 0; 
    position: absolute; 
    width: 1px; }
```


